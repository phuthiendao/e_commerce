SET search_path TO e_commerce_staging, public;

--------------------------------

CREATE INDEX idx_events_event_date ON events(event_date);
CREATE INDEX idx_events_customer_id ON events(customer_id);
CREATE INDEX idx_events_type_refunded ON events(event_type, is_refunded);


------------------------------------------------------------------------
-- Defining Loyal Customers using RFM Analysis
-- Loyal customers, when defined through the lens of RFM Analysis, 
-- are typically the customers who score highest across all three dimensions: Recency, Frequency, and Monetary.

-- Recency (R): The most recent purchase date.
-- Frequency (F): The number of transactions over a specific period.
-- Monetary (M): The total revenue/value generated by the customer.


-- RFM view table
CREATE MATERIALIZED VIEW mv_rfm AS
WITH reference_date AS (
    SELECT MAX(event_date)::date + INTERVAL '1 day' AS reference_date
    FROM events
),
rfm AS (
    SELECT
        customer_id,
        (SELECT reference_date FROM reference_date) - MAX(event_date)::date AS recency_days,
        COUNT(*) AS frequency_orders,
        SUM(net_revenue_usd) AS monetary_usd
    FROM events
    WHERE event_type IN ('order', 'invoice')
      AND is_refunded = false
    GROUP BY customer_id
)
SELECT
    customer_id,
    recency_days,
    frequency_orders,
    monetary_usd,
    (6 - NTILE(5) OVER (ORDER BY recency_days ASC)) AS r_score, -- R: closer and closer → higher score
    NTILE(5) OVER (ORDER BY frequency_orders ASC) AS f_score,   -- F: the more orders → the higher score
    NTILE(5) OVER (ORDER BY monetary_usd ASC) AS m_score,       -- M: the more total money → the higher score
    -- RFM score_string (rfm)
    (6 - NTILE(5) OVER (ORDER BY recency_days ASC))::text ||
    NTILE(5) OVER (ORDER BY frequency_orders ASC)::text ||
    NTILE(5) OVER (ORDER BY monetary_usd ASC)::text AS rfm_score_str,
    -- RFM score (total R+F+M)
    (6 - NTILE(5) OVER (ORDER BY recency_days ASC)) + NTILE(5) OVER (ORDER BY frequency_orders ASC) + NTILE(5) OVER (ORDER BY monetary_usd ASC) AS rfm_score
FROM rfm;

REFRESH MATERIALIZED VIEW mv_rfm;


SELECT
    -- % of revenue
    SUM(CASE WHEN (rfm_score>=12 AND f_score >= 4 AND r_score >= 3) THEN monetary_usd ELSE 0 END) * 100.0 
        / SUM(monetary_usd) AS percent_revenue_loyal,
    -- % of transactions
    SUM(CASE WHEN (rfm_score>=12 AND f_score >= 4 AND r_score >= 3) THEN frequency_orders ELSE 0 END) * 100.0 
        / SUM(frequency_orders) AS percent_orders_loyal
FROM mv_rfm;


-- Loyal customers view table
CREATE MATERIALIZED VIEW loyal_customers AS
SELECT customer_id,recency_days, frequency_orders, monetary_usd, rfm_score_str, rfm_score
FROM mv_rfm
WHERE rfm_score>=12 AND f_score >= 4 AND r_score >= 3
ORDER BY rfm_score DESC;


CREATE INDEX idx_loyal_customers_customer_id ON loyal_customers (customer_id);


REFRESH MATERIALIZED VIEW loyal_customers;

EXPLAIN 
SELECT *
FROM loyal_customers;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--- 1. Total sales change by month
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', event_date) AS sales_month,
        SUM(net_revenue_usd) AS total_sales_usd
    FROM events
    GROUP BY sales_month -- = DATE_TRUNC('month', event_date)
    ORDER BY sales_month
)
SELECT
    TO_CHAR(sales_month, 'YYYY-MM') AS month,
    total_sales_usd,
    prev_month_sales,
    ROUND(
        CASE 
            WHEN prev_month_sales IS NULL THEN NULL
            ELSE (total_sales_usd - prev_month_sales) / prev_month_sales * 100
        END, 2
    ) AS pct_change
FROM (
    SELECT
        sales_month,
        total_sales_usd,
        LAG(total_sales_usd) OVER (ORDER BY sales_month) AS prev_month_sales
    FROM monthly_sales
) AS t



-- 2. total sales change by month partition region
WITH monthly_sales_by_region AS (
    SELECT
        c.region,
        DATE_TRUNC('month', e.event_date) AS month_start,
        SUM(e.net_revenue_usd) AS total_sales_usd
    FROM events e
    LEFT JOIN countries c ON e.country_code = c.country_code
    GROUP BY c.region, DATE_TRUNC('month', e.event_date)
)
SELECT
    region,
    TO_CHAR(month_start, 'YYYY-MM') AS month,
    total_sales_usd,
    prev_month_sales,
    ROUND(
        CASE 
            WHEN prev_month_sales IS NULL THEN NULL
            ELSE (total_sales_usd - prev_month_sales) / prev_month_sales * 100
        END, 2
    ) AS pct_change
FROM (
    SELECT
        region,
        month_start,
        total_sales_usd,
        LAG(total_sales_usd) OVER (PARTITION BY region ORDER BY month_start) AS prev_month_sales
    FROM monthly_sales_by_region
    --WHERE region = 'EU'
) AS t
ORDER BY region, month_start;



-- 3. channels bring in the most sales
SELECT e.channel,
       SUM(net_revenue_usd) AS total_sales_usd
FROM events e
GROUP BY e.channel;



-- 4. channels bring the most repeat (loyal) customers
WITH customer_channel_metrics AS (
    --Step 1: Calculate the number of transactions for each customer on each Channel
    SELECT customer_id, channel,
    		COUNT(DISTINCT event_id) AS event_count
    FROM events
    WHERE event_type IN ('order', 'invoice') AND (is_refunded = FALSE OR is_refunded IS NULL)
    GROUP BY customer_id, channel
)
SELECT
    channel,
    -- Step 2: Calculate the total number of customers who have transacted on that channel
    COUNT(DISTINCT customer_id) AS total_customers,
    -- Step 3: Calculate the number of repeat customers (>= 2 times) on that channel
    COUNT(DISTINCT CASE WHEN event_count >= 2 THEN customer_id END) AS repeat_customers,
    -- Step 4: Calculate the ratio
    ROUND(100.0 * COUNT(DISTINCT CASE WHEN event_count >= 2 THEN customer_id END) / COUNT(DISTINCT customer_id),2) AS repeat_rate_percent
FROM customer_channel_metrics
GROUP BY channel
ORDER BY repeat_rate_percent DESC;


-- channels bring the most repeat (loyal) customers 2
WITH loyal_customer_events AS (
    -- Lọc các event của loyal customers
    SELECT e.customer_id, e.channel, e.event_id
    FROM events e
    JOIN loyal_customers lc
      ON e.customer_id = lc.customer_id
    WHERE e.event_type IN ('order', 'invoice')
      AND (e.is_refunded = FALSE OR e.is_refunded IS NULL)
),
customer_channel_metrics AS (
    -- Tính số event cho mỗi customer trên mỗi channel
    SELECT customer_id, channel, COUNT(event_id) AS event_count
    FROM loyal_customer_events
    GROUP BY customer_id, channel
)
SELECT
    channel,
    COUNT(DISTINCT customer_id) AS total_customers,
    COUNT(DISTINCT CASE WHEN event_count >= 2 THEN customer_id END) AS repeat_customers,
    ROUND(
        100.0 * COUNT(DISTINCT CASE WHEN event_count >= 2 THEN customer_id END)
              / COUNT(DISTINCT customer_id)
    , 2) AS repeat_rate_percent
FROM customer_channel_metrics
GROUP BY channel
ORDER BY repeat_rate_percent DESC;



-- 5. Products or plans sell the most
SELECT 
	e.product_id,
    p.product_name,
    v.vendor_name,
    COUNT(*) AS total_orders,
    SUM(e.quantity) AS total_units_sold
FROM events e
JOIN products p ON e.product_id = p.product_id
JOIN vendors v ON p.vendor_id = v.vendor_id
WHERE e.event_type IN ('order', 'invoice')  
  AND e.is_refunded = FALSE 
GROUP BY p.product_name, e.product_id,v.vendor_name
ORDER BY total_orders DESC
LIMIT 10;



-- 6. Which products are most popular with loyal customers?
SELECT
    p.product_id,
    p.product_name,
    COUNT(DISTINCT e.event_id) AS total_orders,
    SUM(e.quantity) AS total_units_sold
FROM events e
JOIN loyal_customers lc ON e.customer_id = lc.customer_id
JOIN products p ON e.product_id = p.product_id
WHERE e.event_type IN ('order', 'invoice') AND (e.is_refunded = FALSE OR e.is_refunded IS NULL)
GROUP BY p.product_id, p.product_name
ORDER BY total_orders DESC
LIMIT 20;  -- top 20 products


-- 7. What is the average time (days) between consecutive purchases for each customer?
WITH ranked_purchases AS (
    -- Rank each purchase per customer
    SELECT
        e.customer_id,
        e.event_date,
        ROW_NUMBER() OVER (PARTITION BY e.customer_id ORDER BY e.event_date) AS purchase_order
    FROM events e
    WHERE e.event_type IN ('order', 'invoice')
      AND e.is_refunded = FALSE
),
purchase_intervals AS (
    -- Calculate time difference between consecutive purchases
    SELECT
        r1.customer_id,
        EXTRACT(EPOCH FROM (r2.event_date - r1.event_date)) / 86400 AS days_between_purchases
    FROM ranked_purchases r1
    JOIN ranked_purchases r2
      ON r1.customer_id = r2.customer_id
     AND r2.purchase_order = r1.purchase_order + 1
)
-- Average time between purchases per customer
SELECT
    customer_id,
    round(AVG(days_between_purchases),1) AS avg_days_between_purchases
FROM purchase_intervals
GROUP BY customer_id
ORDER BY avg_days_between_purchases DESC;



-- 8. Which discount codes are used most, and do they increase repeat purchases?
-- Most used discount codes
SELECT
    discount_code,
    COUNT(*) AS usage_count,
    COUNT(DISTINCT customer_id) AS unique_customers
FROM events
WHERE discount_code IS NOT NULL AND discount_code != 'N/A'
  AND event_type IN ('order', 'invoice')
  AND is_refunded = FALSE
GROUP BY discount_code
ORDER BY usage_count DESC
--LIMIT 10;

-- discount increase repeat purchases
WITH customer_code_events AS (
    SELECT
        e.customer_id,
        e.discount_code,
        COUNT(DISTINCT e.event_id) AS orders_with_code
    FROM events e
    WHERE e.event_type IN ('order', 'invoice')
      AND (e.is_refunded = FALSE OR e.is_refunded IS NULL)
      AND e.discount_code IS NOT NULL AND discount_code != 'N/A'
    GROUP BY e.customer_id, e.discount_code
),
repeat_stats AS (
    SELECT
        discount_code,
        COUNT(DISTINCT customer_id) AS total_customers,
        COUNT(DISTINCT CASE WHEN orders_with_code >= 2 THEN customer_id END) AS repeat_customers,
        ROUND(100.0 * COUNT(DISTINCT CASE WHEN orders_with_code >= 2 THEN customer_id END)
              / COUNT(DISTINCT customer_id), 2) AS repeat_rate_percent
    FROM customer_code_events
    GROUP BY discount_code
)
SELECT *
FROM repeat_stats
ORDER BY repeat_rate_percent DESC;



-- 9. What is the average selling price (ASP) by country or currency?
-- By country
SELECT 
    e.country_code,
    ROUND(SUM(e.net_revenue_local) / SUM(e.quantity), 2) AS average_selling_price
FROM events e
WHERE e.event_type IN ('order', 'invoice')  -- Lọc sự kiện là 'order' hoặc 'invoice'
  AND e.is_refunded = FALSE  -- Loại bỏ các đơn hàng đã hoàn tiền
GROUP BY e.country_code
ORDER BY average_selling_price DESC;


SELECT 
    e.currency,
    ROUND(SUM(e.net_revenue_local) / SUM(e.quantity), 2) AS average_selling_price
FROM events e
WHERE e.event_type IN ('order', 'invoice')  -- Lọc sự kiện là 'order' hoặc 'invoice'
  AND e.is_refunded = FALSE  -- Loại bỏ các đơn hàng đã hoàn tiền
GROUP BY e.currency
ORDER BY average_selling_price DESC;



-- 10. Where do refunds happen most (by product or channel)?
-- by product
SELECT 
    product_id,
    COUNT(*) FILTER (WHERE is_refunded = TRUE) AS refund_count,
    COUNT(*) AS total_orders,
    ROUND(COUNT(*) FILTER (WHERE is_refunded = TRUE)::decimal / COUNT(*) * 100, 2) AS refund_rate_percent
FROM events
WHERE event_type IN ('order','invoice')
GROUP BY product_id
ORDER BY refund_rate_percent DESC;

-- by channel
SELECT 
    channel,
    COUNT(*) FILTER (WHERE is_refunded = TRUE) AS refund_count,
    COUNT(*) AS total_orders,
    ROUND(COUNT(*) FILTER (WHERE is_refunded = TRUE)::decimal / COUNT(*) * 100, 2) AS refund_rate_percent
FROM events
WHERE event_type IN ('order','invoice')
GROUP BY channel
ORDER BY refund_rate_percent DESC;


-- 11. Do annual plans bring higher revenue per customer than monthly plans?
SELECT 
    p.billing_cycle,
    COUNT(DISTINCT e.customer_id) AS num_customers,
    SUM(e.net_revenue_usd) AS total_revenue,
    ROUND(SUM(e.net_revenue_usd) / COUNT(DISTINCT e.customer_id), 2) AS revenue_per_customer
FROM events e
JOIN products p ON e.product_id = p.product_id
WHERE e.is_refunded = FALSE
  AND e.event_type IN ('order', 'invoice')
GROUP BY p.billing_cycle
ORDER BY revenue_per_customer DESC;


-----------------------------------------------------------------------------------------------------------------------------

SELECT
    e.event_id, e.event_date, c.customer_id, p.product_id, p.product_name, v.vendor_name,
    c2.country_name, c2.region, e.quantity, e.unit_price_local, e.net_revenue_local, e.discount_local, e.is_refunded
FROM events e 
JOIN products p  ON e.product_id = p.product_id 
JOIN customers c ON e.customer_id = c.customer_id 
JOIN countries c2 ON e.country_code = c2.country_code
LEFT JOIN refunds r ON e.event_id = r.event_id
JOIN vendors v  ON v.vendor_id = p.vendor_id;



SELECT min(event_date ), max(event_date )
FROM events
WHERE country_code IN ('US','CA')


SELECT count(*)
FROM events e 

SELECT count(*)
FROM customers c 
WHERE country_code IN ('US','CA')



